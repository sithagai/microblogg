<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/dependencies/amd/lib/r.js/parse.js - js-file</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="js-file"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/builders.html">builders</a></li>
            
                <li><a href="../classes/comments.html">comments</a></li>
            
                <li><a href="../classes/dependencies.html">dependencies</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/comments.html">comments</a></li>
            
                <li><a href="../modules/jsfile.html">jsfile</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/dependencies/amd/lib/r.js/parse.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// https://github.com/jrburke/r.js/blob/master/build/jslib/parse.js
// on Jan 10 2014

/**
 * @license Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */

/*jslint plusplus: true */
/*global define: false */

// original:
// define([&#x27;./esprimaAdapter&#x27;, &#x27;lang&#x27;], function (esprima, lang) {
// modified:
if (typeof define !== &#x27;function&#x27;) { var define = require(&#x27;amdefine&#x27;)(module) }
define([&#x27;esprima&#x27;, &#x27;./lang&#x27;], function (esprima, lang) {
    &#x27;use strict&#x27;;

    function arrayToString(ary) {
        var output = &#x27;[&#x27;;
        if (ary) {
            ary.forEach(function (item, i) {
                output += (i &gt; 0 ? &#x27;,&#x27; : &#x27;&#x27;) + &#x27;&quot;&#x27; + lang.jsEscape(item) + &#x27;&quot;&#x27;;
            });
        }
        output += &#x27;]&#x27;;

        return output;
    }

    //This string is saved off because JSLint complains
    //about obj.arguments use, as &#x27;reserved word&#x27;
    var argPropName = &#x27;arguments&#x27;;

    //From an esprima example for traversing its ast.
    function traverse(object, visitor) {
        var key, child;

        if (!object) {
            return;
        }

        if (visitor.call(null, object) === false) {
            return false;
        }
        for (key in object) {
            if (object.hasOwnProperty(key)) {
                child = object[key];
                if (typeof child === &#x27;object&#x27; &amp;&amp; child !== null) {
                    if (traverse(child, visitor) === false) {
                        return false;
                    }
                }
            }
        }
    }

    //Like traverse, but visitor returning false just
    //stops that subtree analysis, not the rest of tree
    //visiting.
    function traverseBroad(object, visitor) {
        var key, child;

        if (!object) {
            return;
        }

        if (visitor.call(null, object) === false) {
            return false;
        }
        for (key in object) {
            if (object.hasOwnProperty(key)) {
                child = object[key];
                if (typeof child === &#x27;object&#x27; &amp;&amp; child !== null) {
                    traverse(child, visitor);
                }
            }
        }
    }

    /**
     * Pulls out dependencies from an array literal with just string members.
     * If string literals, will just return those string values in an array,
     * skipping other items in the array.
     *
     * @param {Node} node an AST node.
     *
     * @returns {Array} an array of strings.
     * If null is returned, then it means the input node was not a valid
     * dependency.
     */
    function getValidDeps(node) {
        if (!node || node.type !== &#x27;ArrayExpression&#x27; || !node.elements) {
            return;
        }

        var deps = [];

        node.elements.some(function (elem) {
            if (elem.type === &#x27;Literal&#x27;) {
                deps.push(elem.value);
            }
        });

        return deps.length ? deps : undefined;
    }

    /**
     * Main parse function. Returns a string of any valid require or
     * define/require.def calls as part of one JavaScript source string.
     * @param {String} moduleName the module name that represents this file.
     * It is used to create a default define if there is not one already for the
     * file. This allows properly tracing dependencies for builds. Otherwise, if
     * the file just has a require() call, the file dependencies will not be
     * properly reflected: the file will come before its dependencies.
     * @param {String} moduleName
     * @param {String} fileName
     * @param {String} fileContents
     * @param {Object} options optional options. insertNeedsDefine: true will
     * add calls to require.needsDefine() if appropriate.
     * @returns {String} JS source string or null, if no require or
     * define/require.def calls are found.
     */
    function parse(moduleName, fileName, fileContents, options) {
        options = options || {};

        //Set up source input
        var i, moduleCall, depString,
            moduleDeps = [],
            result = &#x27;&#x27;,
            moduleList = [],
            needsDefine = true,
            astRoot = esprima.parse(fileContents);

        parse.recurse(astRoot, function (callName, config, name, deps) {
            if (!deps) {
                deps = [];
            }

            if (callName === &#x27;define&#x27; &amp;&amp; (!name || name === moduleName)) {
                needsDefine = false;
            }

            if (!name) {
                //If there is no module name, the dependencies are for
                //this file/default module name.
                moduleDeps = moduleDeps.concat(deps);
            } else {
                moduleList.push({
                    name: name,
                    deps: deps
                });
            }

            //If define was found, no need to dive deeper, unless
            //the config explicitly wants to dig deeper.
            return !!options.findNestedDependencies;
        }, options);

        if (options.insertNeedsDefine &amp;&amp; needsDefine) {
            result += &#x27;require.needsDefine(&quot;&#x27; + moduleName + &#x27;&quot;);&#x27;;
        }

        if (moduleDeps.length || moduleList.length) {
            for (i = 0; i &lt; moduleList.length; i++) {
                moduleCall = moduleList[i];
                if (result) {
                    result += &#x27;\n&#x27;;
                }

                //If this is the main module for this file, combine any
                //&quot;anonymous&quot; dependencies (could come from a nested require
                //call) with this module.
                if (moduleCall.name === moduleName) {
                    moduleCall.deps = moduleCall.deps.concat(moduleDeps);
                    moduleDeps = [];
                }

                depString = arrayToString(moduleCall.deps);
                result += &#x27;define(&quot;&#x27; + moduleCall.name + &#x27;&quot;,&#x27; +
                          depString + &#x27;);&#x27;;
            }
            if (moduleDeps.length) {
                if (result) {
                    result += &#x27;\n&#x27;;
                }
                depString = arrayToString(moduleDeps);
                result += &#x27;define(&quot;&#x27; + moduleName + &#x27;&quot;,&#x27; + depString + &#x27;);&#x27;;
            }
        }

        return result || null;
    }

    parse.traverse = traverse;
    parse.traverseBroad = traverseBroad;

    /**
     * Handles parsing a file recursively for require calls.
     * @param {Array} parentNode the AST node to start with.
     * @param {Function} onMatch function to call on a parse match.
     * @param {Object} [options] This is normally the build config options if
     * it is passed.
     */
    parse.recurse = function (object, onMatch, options) {
        //Like traverse, but skips if branches that would not be processed
        //after has application that results in tests of true or false boolean
        //literal values.
        var key, child,
            hasHas = options &amp;&amp; options.has;

        if (!object) {
            return;
        }

        //If has replacement has resulted in if(true){} or if(false){}, take
        //the appropriate branch and skip the other one.
        if (hasHas &amp;&amp; object.type === &#x27;IfStatement&#x27; &amp;&amp; object.test.type &amp;&amp;
                object.test.type === &#x27;Literal&#x27;) {
            if (object.test.value) {
                //Take the if branch
                this.recurse(object.consequent, onMatch, options);
            } else {
                //Take the else branch
                this.recurse(object.alternate, onMatch, options);
            }
        } else {
            if (this.parseNode(object, onMatch) === false) {
                return;
            }
            for (key in object) {
                if (object.hasOwnProperty(key)) {
                    child = object[key];
                    if (typeof child === &#x27;object&#x27; &amp;&amp; child !== null) {
                        this.recurse(child, onMatch, options);
                    }
                }
            }
        }
    };

    /**
     * Determines if the file defines the require/define module API.
     * Specifically, it looks for the &#x60;define.amd = &#x60; expression.
     * @param {String} fileName
     * @param {String} fileContents
     * @returns {Boolean}
     */
    parse.definesRequire = function (fileName, fileContents) {
        var found = false;

        traverse(esprima.parse(fileContents), function (node) {
            if (parse.hasDefineAmd(node)) {
                found = true;

                //Stop traversal
                return false;
            }
        });

        return found;
    };

    /**
     * Finds require(&quot;&quot;) calls inside a CommonJS anonymous module wrapped in a
     * define(function(require, exports, module){}) wrapper. These dependencies
     * will be added to a modified define() call that lists the dependencies
     * on the outside of the function.
     * @param {String} fileName
     * @param {String|Object} fileContents: a string of contents, or an already
     * parsed AST tree.
     * @returns {Array} an array of module names that are dependencies. Always
     * returns an array, but could be of length zero.
     */
    parse.getAnonDeps = function (fileName, fileContents) {
        var astRoot = typeof fileContents === &#x27;string&#x27; ?
                      esprima.parse(fileContents) : fileContents,
            defFunc = this.findAnonDefineFactory(astRoot);

        return parse.getAnonDepsFromNode(defFunc);
    };

    /**
     * Finds require(&quot;&quot;) calls inside a CommonJS anonymous module wrapped
     * in a define function, given an AST node for the definition function.
     * @param {Node} node the AST node for the definition function.
     * @returns {Array} and array of dependency names. Can be of zero length.
     */
    parse.getAnonDepsFromNode = function (node) {
        var deps = [],
            funcArgLength;

        if (node) {
            this.findRequireDepNames(node, deps);

            //If no deps, still add the standard CommonJS require, exports,
            //module, in that order, to the deps, but only if specified as
            //function args. In particular, if exports is used, it is favored
            //over the return value of the function, so only add it if asked.
            funcArgLength = node.params &amp;&amp; node.params.length;
            if (funcArgLength) {
                deps = (funcArgLength &gt; 1 ? [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;] :
                        [&quot;require&quot;]).concat(deps);
            }
        }
        return deps;
    };

    parse.isDefineNodeWithArgs = function (node) {
        return node &amp;&amp; node.type === &#x27;CallExpression&#x27; &amp;&amp;
               node.callee &amp;&amp; node.callee.type === &#x27;Identifier&#x27; &amp;&amp;
               node.callee.name === &#x27;define&#x27; &amp;&amp; node[argPropName];
    };

    /**
     * Finds the function in define(function (require, exports, module){});
     * @param {Array} node
     * @returns {Boolean}
     */
    parse.findAnonDefineFactory = function (node) {
        var match;

        traverse(node, function (node) {
            var arg0, arg1;

            if (parse.isDefineNodeWithArgs(node)) {

                //Just the factory function passed to define
                arg0 = node[argPropName][0];
                if (arg0 &amp;&amp; arg0.type === &#x27;FunctionExpression&#x27;) {
                    match = arg0;
                    return false;
                }

                //A string literal module ID followed by the factory function.
                arg1 = node[argPropName][1];
                if (arg0.type === &#x27;Literal&#x27; &amp;&amp;
                        arg1 &amp;&amp; arg1.type === &#x27;FunctionExpression&#x27;) {
                    match = arg1;
                    return false;
                }
            }
        });

        return match;
    };

    /**
     * Finds any config that is passed to requirejs. That includes calls to
     * require/requirejs.config(), as well as require({}, ...) and
     * requirejs({}, ...)
     * @param {String} fileContents
     *
     * @returns {Object} a config details object with the following properties:
     * - config: {Object} the config object found. Can be undefined if no
     * config found.
     * - range: {Array} the start index and end index in the contents where
     * the config was found. Can be undefined if no config found.
     * Can throw an error if the config in the file cannot be evaluated in
     * a build context to valid JavaScript.
     */
    parse.findConfig = function (fileContents) {
        /*jslint evil: true */
        var jsConfig, foundConfig, stringData, foundRange, quote, quoteMatch,
            quoteRegExp = /(:\s|\[\s*)([&#x27;&quot;])/,
            astRoot = esprima.parse(fileContents, {
                loc: true
            });

        traverse(astRoot, function (node) {
            var arg,
                requireType = parse.hasRequire(node);

            if (requireType &amp;&amp; (requireType === &#x27;require&#x27; ||
                    requireType === &#x27;requirejs&#x27; ||
                    requireType === &#x27;requireConfig&#x27; ||
                    requireType === &#x27;requirejsConfig&#x27;)) {

                arg = node[argPropName] &amp;&amp; node[argPropName][0];

                if (arg &amp;&amp; arg.type === &#x27;ObjectExpression&#x27;) {
                    stringData = parse.nodeToString(fileContents, arg);
                    jsConfig = stringData.value;
                    foundRange = stringData.range;
                    return false;
                }
            } else {
                arg = parse.getRequireObjectLiteral(node);
                if (arg) {
                    stringData = parse.nodeToString(fileContents, arg);
                    jsConfig = stringData.value;
                    foundRange = stringData.range;
                    return false;
                }
            }
        });

        if (jsConfig) {
            // Eval the config
            quoteMatch = quoteRegExp.exec(jsConfig);
            quote = (quoteMatch &amp;&amp; quoteMatch[2]) || &#x27;&quot;&#x27;;
            foundConfig = eval(&#x27;(&#x27; + jsConfig + &#x27;)&#x27;);
        }

        return {
            config: foundConfig,
            range: foundRange,
            quote: quote
        };
    };

    /** Returns the node for the object literal assigned to require/requirejs,
     * for holding a declarative config.
     */
    parse.getRequireObjectLiteral = function (node) {
        if (node.id &amp;&amp; node.id.type === &#x27;Identifier&#x27; &amp;&amp;
                (node.id.name === &#x27;require&#x27; || node.id.name === &#x27;requirejs&#x27;) &amp;&amp;
                node.init &amp;&amp; node.init.type === &#x27;ObjectExpression&#x27;) {
            return node.init;
        }
    };

    /**
     * Renames require/requirejs/define calls to be ns + &#x27;.&#x27; + require/requirejs/define
     * Does *not* do .config calls though. See pragma.namespace for the complete
     * set of namespace transforms. This function is used because require calls
     * inside a define() call should not be renamed, so a simple regexp is not
     * good enough.
     * @param  {String} fileContents the contents to transform.
     * @param  {String} ns the namespace, *not* including trailing dot.
     * @return {String} the fileContents with the namespace applied
     */
    parse.renameNamespace = function (fileContents, ns) {
        var lines,
            locs = [],
            astRoot = esprima.parse(fileContents, {
                loc: true
            });

        parse.recurse(astRoot, function (callName, config, name, deps, node) {
            locs.push(node.loc);
            //Do not recurse into define functions, they should be using
            //local defines.
            return callName !== &#x27;define&#x27;;
        }, {});

        if (locs.length) {
            lines = fileContents.split(&#x27;\n&#x27;);

            //Go backwards through the found locs, adding in the namespace name
            //in front.
            locs.reverse();
            locs.forEach(function (loc) {
                var startIndex = loc.start.column,
                //start.line is 1-based, not 0 based.
                lineIndex = loc.start.line - 1,
                line = lines[lineIndex];

                lines[lineIndex] = line.substring(0, startIndex) +
                                   ns + &#x27;.&#x27; +
                                   line.substring(startIndex,
                                                      line.length);
            });

            fileContents = lines.join(&#x27;\n&#x27;);
        }

        return fileContents;
    };

    /**
     * Finds all dependencies specified in dependency arrays and inside
     * simplified commonjs wrappers.
     * @param {String} fileName
     * @param {String} fileContents
     *
     * @returns {Array} an array of dependency strings. The dependencies
     * have not been normalized, they may be relative IDs.
     */
    parse.findDependencies = function (fileName, fileContents, options) {
        var dependencies = [],
            astRoot = esprima.parse(fileContents);

        parse.recurse(astRoot, function (callName, config, name, deps) {
            if (deps) {
                dependencies = dependencies.concat(deps);
            }
        }, options);

        return dependencies;
    };

    /**
     * Finds only CJS dependencies, ones that are the form
     * require(&#x27;stringLiteral&#x27;)
     */
    parse.findCjsDependencies = function (fileName, fileContents) {
        var dependencies = [];

        traverse(esprima.parse(fileContents), function (node) {
            var arg;

            if (node &amp;&amp; node.type === &#x27;CallExpression&#x27; &amp;&amp; node.callee &amp;&amp;
                    node.callee.type === &#x27;Identifier&#x27; &amp;&amp;
                    node.callee.name === &#x27;require&#x27; &amp;&amp; node[argPropName] &amp;&amp;
                    node[argPropName].length === 1) {
                arg = node[argPropName][0];
                if (arg.type === &#x27;Literal&#x27;) {
                    dependencies.push(arg.value);
                }
            }
        });

        return dependencies;
    };

    //function define() {}
    parse.hasDefDefine = function (node) {
        return node.type === &#x27;FunctionDeclaration&#x27; &amp;&amp; node.id &amp;&amp;
                    node.id.type === &#x27;Identifier&#x27; &amp;&amp; node.id.name === &#x27;define&#x27;;
    };

    //define.amd = ...
    parse.hasDefineAmd = function (node) {
        return node &amp;&amp; node.type === &#x27;AssignmentExpression&#x27; &amp;&amp;
            node.left &amp;&amp; node.left.type === &#x27;MemberExpression&#x27; &amp;&amp;
            node.left.object &amp;&amp; node.left.object.name === &#x27;define&#x27; &amp;&amp;
            node.left.property &amp;&amp; node.left.property.name === &#x27;amd&#x27;;
    };

    //define.amd reference, as in: if (define.amd)
    parse.refsDefineAmd = function (node) {
        return node &amp;&amp; node.type === &#x27;MemberExpression&#x27; &amp;&amp;
        node.object &amp;&amp; node.object.name === &#x27;define&#x27; &amp;&amp;
        node.object.type === &#x27;Identifier&#x27; &amp;&amp;
        node.property &amp;&amp; node.property.name === &#x27;amd&#x27; &amp;&amp;
        node.property.type === &#x27;Identifier&#x27;;
    };

    //require(), requirejs(), require.config() and requirejs.config()
    parse.hasRequire = function (node) {
        var callName,
            c = node &amp;&amp; node.callee;

        if (node &amp;&amp; node.type === &#x27;CallExpression&#x27; &amp;&amp; c) {
            if (c.type === &#x27;Identifier&#x27; &amp;&amp;
                    (c.name === &#x27;require&#x27; ||
                    c.name === &#x27;requirejs&#x27;)) {
                //A require/requirejs({}, ...) call
                callName = c.name;
            } else if (c.type === &#x27;MemberExpression&#x27; &amp;&amp;
                    c.object &amp;&amp;
                    c.object.type === &#x27;Identifier&#x27; &amp;&amp;
                    (c.object.name === &#x27;require&#x27; ||
                        c.object.name === &#x27;requirejs&#x27;) &amp;&amp;
                    c.property &amp;&amp; c.property.name === &#x27;config&#x27;) {
                // require/requirejs.config({}) call
                callName = c.object.name + &#x27;Config&#x27;;
            }
        }

        return callName;
    };

    //define()
    parse.hasDefine = function (node) {
        return node &amp;&amp; node.type === &#x27;CallExpression&#x27; &amp;&amp; node.callee &amp;&amp;
            node.callee.type === &#x27;Identifier&#x27; &amp;&amp;
            node.callee.name === &#x27;define&#x27;;
    };

    /**
     * If there is a named define in the file, returns the name. Does not
     * scan for mulitple names, just the first one.
     */
    parse.getNamedDefine = function (fileContents) {
        var name;
        traverse(esprima.parse(fileContents), function (node) {
            if (node &amp;&amp; node.type === &#x27;CallExpression&#x27; &amp;&amp; node.callee &amp;&amp;
            node.callee.type === &#x27;Identifier&#x27; &amp;&amp;
            node.callee.name === &#x27;define&#x27; &amp;&amp;
            node[argPropName] &amp;&amp; node[argPropName][0] &amp;&amp;
            node[argPropName][0].type === &#x27;Literal&#x27;) {
                name = node[argPropName][0].value;
                return false;
            }
        });

        return name;
    };

    /**
     * Determines if define(), require({}|[]) or requirejs was called in the
     * file. Also finds out if define() is declared and if define.amd is called.
     */
    parse.usesAmdOrRequireJs = function (fileName, fileContents) {
        var uses;

        traverse(esprima.parse(fileContents), function (node) {
            var type, callName, arg;

            if (parse.hasDefDefine(node)) {
                //function define() {}
                type = &#x27;declaresDefine&#x27;;
            } else if (parse.hasDefineAmd(node)) {
                type = &#x27;defineAmd&#x27;;
            } else {
                callName = parse.hasRequire(node);
                if (callName) {
                    arg = node[argPropName] &amp;&amp; node[argPropName][0];
                    if (arg &amp;&amp; (arg.type === &#x27;ObjectExpression&#x27; ||
                            arg.type === &#x27;ArrayExpression&#x27;)) {
                        type = callName;
                    }
                } else if (parse.hasDefine(node)) {
                    type = &#x27;define&#x27;;
                }
            }

            if (type) {
                if (!uses) {
                    uses = {};
                }
                uses[type] = true;
            }
        });

        return uses;
    };

    /**
     * Determines if require(&#x27;&#x27;), exports.x =, module.exports =,
     * __dirname, __filename are used. So, not strictly traditional CommonJS,
     * also checks for Node variants.
     */
    parse.usesCommonJs = function (fileName, fileContents) {
        var uses = null,
            assignsExports = false;


        traverse(esprima.parse(fileContents), function (node) {
            var type,
                exp = node.expression || node.init;

            if (node.type === &#x27;Identifier&#x27; &amp;&amp;
                    (node.name === &#x27;__dirname&#x27; || node.name === &#x27;__filename&#x27;)) {
                type = node.name.substring(2);
            } else if (node.type === &#x27;VariableDeclarator&#x27; &amp;&amp; node.id &amp;&amp;
                    node.id.type === &#x27;Identifier&#x27; &amp;&amp;
                        node.id.name === &#x27;exports&#x27;) {
                //Hmm, a variable assignment for exports, so does not use cjs
                //exports.
                type = &#x27;varExports&#x27;;
            } else if (exp &amp;&amp; exp.type === &#x27;AssignmentExpression&#x27; &amp;&amp; exp.left &amp;&amp;
                    exp.left.type === &#x27;MemberExpression&#x27; &amp;&amp; exp.left.object) {
                if (exp.left.object.name === &#x27;module&#x27; &amp;&amp; exp.left.property &amp;&amp;
                        exp.left.property.name === &#x27;exports&#x27;) {
                    type = &#x27;moduleExports&#x27;;
                } else if (exp.left.object.name === &#x27;exports&#x27; &amp;&amp;
                        exp.left.property) {
                    type = &#x27;exports&#x27;;
                }

            } else if (node &amp;&amp; node.type === &#x27;CallExpression&#x27; &amp;&amp; node.callee &amp;&amp;
                    node.callee.type === &#x27;Identifier&#x27; &amp;&amp;
                    node.callee.name === &#x27;require&#x27; &amp;&amp; node[argPropName] &amp;&amp;
                    node[argPropName].length === 1 &amp;&amp;
                    node[argPropName][0].type === &#x27;Literal&#x27;) {
                type = &#x27;require&#x27;;
            }

            if (type) {
                if (type === &#x27;varExports&#x27;) {
                    assignsExports = true;
                } else if (type !== &#x27;exports&#x27; || !assignsExports) {
                    if (!uses) {
                        uses = {};
                    }
                    uses[type] = true;
                }
            }
        });

        return uses;
    };


    parse.findRequireDepNames = function (node, deps) {
        traverse(node, function (node) {
            var arg;

            if (node &amp;&amp; node.type === &#x27;CallExpression&#x27; &amp;&amp; node.callee &amp;&amp;
                    node.callee.type === &#x27;Identifier&#x27; &amp;&amp;
                    node.callee.name === &#x27;require&#x27; &amp;&amp;
                    node[argPropName] &amp;&amp; node[argPropName].length === 1) {

                arg = node[argPropName][0];
                if (arg.type === &#x27;Literal&#x27;) {
                    deps.push(arg.value);
                }
            }
        });
    };

    /**
     * Determines if a specific node is a valid require or define/require.def
     * call.
     * @param {Array} node
     * @param {Function} onMatch a function to call when a match is found.
     * It is passed the match name, and the config, name, deps possible args.
     * The config, name and deps args are not normalized.
     *
     * @returns {String} a JS source string with the valid require/define call.
     * Otherwise null.
     */
    parse.parseNode = function (node, onMatch) {
        var name, deps, cjsDeps, arg, factory, exp, refsDefine, bodyNode,
            args = node &amp;&amp; node[argPropName],
            callName = parse.hasRequire(node);

        if (callName === &#x27;require&#x27; || callName === &#x27;requirejs&#x27;) {
            //A plain require/requirejs call
            arg = node[argPropName] &amp;&amp; node[argPropName][0];
            if (arg.type !== &#x27;ArrayExpression&#x27;) {
                if (arg.type === &#x27;ObjectExpression&#x27;) {
                    //A config call, try the second arg.
                    arg = node[argPropName][1];
                }
            }

            deps = getValidDeps(arg);
            if (!deps) {
                return;
            }

            return onMatch(&quot;require&quot;, null, null, deps, node);
        } else if (parse.hasDefine(node) &amp;&amp; args &amp;&amp; args.length) {
            name = args[0];
            deps = args[1];
            factory = args[2];

            if (name.type === &#x27;ArrayExpression&#x27;) {
                //No name, adjust args
                factory = deps;
                deps = name;
                name = null;
            } else if (name.type === &#x27;FunctionExpression&#x27;) {
                //Just the factory, no name or deps
                factory = name;
                name = deps = null;
            } else if (name.type !== &#x27;Literal&#x27;) {
                 //An object literal, just null out
                name = deps = factory = null;
            }

            if (name &amp;&amp; name.type === &#x27;Literal&#x27; &amp;&amp; deps) {
                if (deps.type === &#x27;FunctionExpression&#x27;) {
                    //deps is the factory
                    factory = deps;
                    deps = null;
                } else if (deps.type === &#x27;ObjectExpression&#x27;) {
                    //deps is object literal, null out
                    deps = factory = null;
                } else if (deps.type === &#x27;Identifier&#x27; &amp;&amp; args.length === 2) {
                    // define(&#x27;id&#x27;, factory)
                    deps = factory = null;
                }
            }

            if (deps &amp;&amp; deps.type === &#x27;ArrayExpression&#x27;) {
                deps = getValidDeps(deps);
            } else if (factory &amp;&amp; factory.type === &#x27;FunctionExpression&#x27;) {
                //If no deps and a factory function, could be a commonjs sugar
                //wrapper, scan the function for dependencies.
                cjsDeps = parse.getAnonDepsFromNode(factory);
                if (cjsDeps.length) {
                    deps = cjsDeps;
                }
            } else if (deps || factory) {
                //Does not match the shape of an AMD call.
                return;
            }

            //Just save off the name as a string instead of an AST object.
            if (name &amp;&amp; name.type === &#x27;Literal&#x27;) {
                name = name.value;
            }

            return onMatch(&quot;define&quot;, null, name, deps, node);
        } else if (node.type === &#x27;CallExpression&#x27; &amp;&amp; node.callee &amp;&amp;
                   node.callee.type === &#x27;FunctionExpression&#x27; &amp;&amp;
                   node.callee.body &amp;&amp; node.callee.body.body &amp;&amp;
                   node.callee.body.body.length === 1 &amp;&amp;
                   node.callee.body.body[0].type === &#x27;IfStatement&#x27;) {
            bodyNode = node.callee.body.body[0];
            //Look for a define(Identifier) case, but only if inside an
            //if that has a define.amd test
            if (bodyNode.consequent &amp;&amp; bodyNode.consequent.body) {
                exp = bodyNode.consequent.body[0];
                if (exp.type === &#x27;ExpressionStatement&#x27; &amp;&amp; exp.expression &amp;&amp;
                    parse.hasDefine(exp.expression) &amp;&amp;
                    exp.expression.arguments &amp;&amp;
                    exp.expression.arguments.length === 1 &amp;&amp;
                    exp.expression.arguments[0].type === &#x27;Identifier&#x27;) {

                    //Calls define(Identifier) as first statement in body.
                    //Confirm the if test references define.amd
                    traverse(bodyNode.test, function (node) {
                        if (parse.refsDefineAmd(node)) {
                            refsDefine = true;
                            return false;
                        }
                    });

                    if (refsDefine) {
                        return onMatch(&quot;define&quot;, null, null, null, exp.expression);
                    }
                }
            }
        }
    };

    /**
     * Converts an AST node into a JS source string by extracting
     * the node&#x27;s location from the given contents string. Assumes
     * esprima.parse() with loc was done.
     * @param {String} contents
     * @param {Object} node
     * @returns {String} a JS source string.
     */
    parse.nodeToString = function (contents, node) {
        var extracted,
            loc = node.loc,
            lines = contents.split(&#x27;\n&#x27;),
            firstLine = loc.start.line &gt; 1 ?
                        lines.slice(0, loc.start.line - 1).join(&#x27;\n&#x27;) + &#x27;\n&#x27; :
                        &#x27;&#x27;,
            preamble = firstLine +
                       lines[loc.start.line - 1].substring(0, loc.start.column);

        if (loc.start.line === loc.end.line) {
            extracted = lines[loc.start.line - 1].substring(loc.start.column,
                                                            loc.end.column);
        } else {
            extracted =  lines[loc.start.line - 1].substring(loc.start.column) +
                     &#x27;\n&#x27; +
                     lines.slice(loc.start.line, loc.end.line - 1).join(&#x27;\n&#x27;) +
                     &#x27;\n&#x27; +
                     lines[loc.end.line - 1].substring(0, loc.end.column);
        }

        return {
            value: extracted,
            range: [
                preamble.length,
                preamble.length + extracted.length
            ]
        };
    };

    /**
     * Extracts license comments from JS text.
     * @param {String} fileName
     * @param {String} contents
     * @returns {String} a string of license comments.
     */
    parse.getLicenseComments = function (fileName, contents) {
        var commentNode, refNode, subNode, value, i, j,
            //xpconnect&#x27;s Reflect does not support comment or range, but
            //prefer continued operation vs strict parity of operation,
            //as license comments can be expressed in other ways, like
            //via wrap args, or linked via sourcemaps.
            ast = esprima.parse(contents, {
                comment: true,
                range: true
            }),
            result = &#x27;&#x27;,
            existsMap = {},
            lineEnd = contents.indexOf(&#x27;\r&#x27;) === -1 ? &#x27;\n&#x27; : &#x27;\r\n&#x27;;

        if (ast.comments) {
            for (i = 0; i &lt; ast.comments.length; i++) {
                commentNode = ast.comments[i];

                if (commentNode.type === &#x27;Line&#x27;) {
                    value = &#x27;//&#x27; + commentNode.value + lineEnd;
                    refNode = commentNode;

                    if (i + 1 &gt;= ast.comments.length) {
                        value += lineEnd;
                    } else {
                        //Look for immediately adjacent single line comments
                        //since it could from a multiple line comment made out
                        //of single line comments. Like this comment.
                        for (j = i + 1; j &lt; ast.comments.length; j++) {
                            subNode = ast.comments[j];
                            if (subNode.type === &#x27;Line&#x27; &amp;&amp;
                                    subNode.range[0] === refNode.range[1] + 1) {
                                //Adjacent single line comment. Collect it.
                                value += &#x27;//&#x27; + subNode.value + lineEnd;
                                refNode = subNode;
                            } else {
                                //No more single line comment blocks. Break out
                                //and continue outer looping.
                                break;
                            }
                        }
                        value += lineEnd;
                        i = j - 1;
                    }
                } else {
                    value = &#x27;/*&#x27; + commentNode.value + &#x27;*/&#x27; + lineEnd + lineEnd;
                }

                if (!existsMap[value] &amp;&amp; (value.indexOf(&#x27;license&#x27;) !== -1 ||
                        (commentNode.type === &#x27;Block&#x27; &amp;&amp;
                            value.indexOf(&#x27;/*!&#x27;) === 0) ||
                        value.indexOf(&#x27;opyright&#x27;) !== -1 ||
                        value.indexOf(&#x27;(c)&#x27;) !== -1)) {

                    result += value;
                    existsMap[value] = true;
                }

            }
        }

        return result;
    };

    return parse;
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
